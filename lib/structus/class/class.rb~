require 'lettercase'
require 'forwardable'

module Structura::Class
  extend Forwardable
  
  class << self
    def def_wrappers(recepter, *methods)
      methods.each do |method|
        def_delegator recepter, method,  :"_#{method}"
      
        define_method method do |*args, &block|
          __send__ :"_#{method}", *args, &block
          self
        end
      end
    end

    def def_wrapped_enums(recepter, *methods)
      methods.each do |method|
        def_delegator recepter, method, :"_#{method}"
        
        define_method method do |*args, &block|
          return to_enum(method) unless block_given?
          __send__ :"_#{method}", *args, &block
          self
        end
      end
    end
  end

  # @note Remind returnning values
  #   safe:   def_wrap[*]
  #   faster: def_delegator[s] 

  def_wrapped_enums :_attrs, :each_member, :each_key
  def_wrapped_enums :members, :each_index

  def members(aliased=false)
    (aliased ? _attrs : _attrs.select{|k, v|v.respond_to? :each_pair}).keys
  end

  alias_method :keys, :members

  def length
    _attrs.length
  end

  alias_method :size, :length

  def has_member?(name)
    _attrs.has_key? name
  end

  alias_method :has_key?, :has_member?

  VALID_OPTIONS = 
    [:is, :via, :default, :reader_validation, :writer_validation].freeze

  def has(name, options={})
    name = name.to_sym
    raise NameError, 'Already defined' if _attrs.has_key? name
    unless (options.keys - VALID_OPTIONS).empty?
      raise ArgumentError, 'Invalid Option Parameter' 
    end
    
    if block_given?
      raise ArgumentError unless options.empty?
      nested = _define_nested_member(&block)
      options = {is: nested, default: ->{nested.new}}
    end

    options.each_pair do |key, value|
      raise ArgumentError unless __send__ "valid_option_in_#{key}?", value
    end
    
    _attrs[name] = options
    
    define_method name do
      _get! name
    end

    define_method :"#{name}=" do |value|
      _set! name, value
    end

    nil
  end

  alias_method :member, :has

  def alias_member(aliased, original)
    _attrs[aliased] = original
   (_attrs(original)[:aliases] ||= []) << aliased

    alias_method aliased, original
    alias_method "#{aliased}=", "#{original}="
  end

  def freeze
    close
    super
  end

  def dup
    cost_set :MEMBER_DEFINES, _attrs.dup
  end

  def valid_option_in_is?(object)
    conditionable? object
  end

  def valid_option_in_via?(object)
    adjustable? object
  end

  def valid_option_in_default?(object)
    object.kind_of?(Proc) ?  (object.arity == 0) : true  
  end

  %w[reader writer].each do |type|
    define_method :"valid_option_in_#{type}_validation?" do |object|
      [true, false].any?{|bool|bool.equal? object}
    end
  end
  
  private

  def close
    _attrs.freeze
    self
  end

  def _attrs(name=nil)
    if name
      if self::MEMBER_DEFINES.has_key? name
        attrs = self::MEMBER_DEFINES[name] #=> aliased_name or attributes
        if attrs.kind_of? Symbol
          self::MEMBER_DEFINES[attrs]
        else
          attrs
        end
      else
        raise
      end
    else
      self::MEMBER_DEFINES
    end
  end

  def _define_nested_member(name, &block)
    const_set name.PascalCase, ::Structual.define {instance_exec(&block)}
  end

end

# require_relative 'constructor'
# require_relative 'handy'
