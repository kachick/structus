module Structura::Instance
  extend Forwardable

  class << self
    def def_wrappers(recepter, *methods)
      methods.each do |method|
        def_delegator recepter, :"_#{method}", method
      end
      
      define_method method do |*args, &block|
        __send__ :"_#{method}", *args, &block
       self
      end
    end

    def def_wrapped_enums(recepter, *methods)
      methods.each do |method|
        def_delegator recepter, :"_#{method}", method
      end
      
      define_method method do |*args, &block|
        return to_enum(method) unless block_given?
        __send__ :"_#{method}", *args, &block
       self
      end
    end
  end

  # @note Remind returnning values
  #   safe:   def_wrap[*]
  #   faster: def_delegator[s] 

  def_delegators :'self.class',
  :members, :keys, :length, :size
  :has_member?, :member?, :has_key?, :key?, :_attrs

  private :_attrs
  

  def_delegators :@_db, :hash, :has_value?, :value?, :empty?

  def_wrapped_enums :'self.class', :each_member, :each_key, :each_index

  def_wrapped_enums :@_db, :each_value, :each_pair # !! when db.unassign

  def initialize(*values)
    @_db, @_locks = {}, {}
    _replace_values(*values)
  end

  def initialize_copy(original)
    @_db, @_locks = @_db.dup, {}
  end

  # @param [Symbol, String] name
  def assign?(name)
    @_db.has_key? name.to_sym
  end
  
  # @param [Symbol, String, Fixnum] key
  def unassign(key)
    _subscript(key) {|name|@_db.delete name}
  end
 
  # @param [Symbol, String] name
  def default?(name)
    _attrs(name)[:default] == self[name]
  end
  
  # @return [Struct]
  def to_struct
    self.class.to_struct_class.new(*values)
  end

  # @return [Boolean]
  def ==(other)
    _compare other, :==
  end

  alias_method :===, :==
  
  def eql?(other)
    _compare other, :eql?
  end

   # @return [String]
  def inspect
    "#<#{self.class} (Structura)".tap {|s|
      each_pair do |name, value|
        suffix = (has_default?(name) && default?(name)) ? '(default)' : nil
        s << " #{name}=#{value.inspect}#{suffix}"
      end
      
      s << ">"
    }
  end

  # @return [String]
  def to_s
    "#<structura #{self.class}".tap {|s|
      each_pair do |name, value|
        s << " #{name}=#{value.inspect}"
      end
      
      s << '>'
    }
  end

  alias_method :each, :each_value
  
  alias_method :to_a, :values

  # @return [Hash]
  def to_h(reject_no_assign=false)
    return @_db.dup if reject_no_assign

    {}.tap {|h|
      each_pair do |key, value|
        h[key] = value
      end
    }
  end

  # @param [Fixnum, Range] *keys
  # @return [Array]
  def values_at(*_keys)
    [].tap {|r|
      _keys.each do |key|
        case key
        when Fixnum
          r << self[key]
        when Range
          key.each do |n|
            raise TypeError unless n.instance_of? Fixnum
            r << self[n]
          end
        else
          raise TypeError
        end
      end
    }
  end

  # @param [Symbol, String, Fixnum] key
  def [](key)
    _subscript(key) {|name|_read name}
  end
  
  # @param [Symbol, String, Fixnum] key
  # @param [Object] value
  # @return [value]
  def []=(key, value)
    _subscript(key) {|name|_write, name, value}
  end

  def freeze
    close
    super
  end

  alias_method :value?, :has_value?

  # @param [Symbol, String] name
  # @param [Object] value - no argument and use own
  # passed under any condition
  def valid?(name, value=self[name.to_sym])
    return true unless restrict? name
    
    _valid? condition_for(name), value
  end

  # true if all members passed under any condition
  def strict?
    each_pair.all?{|name, value|sufficient? name, value}
  end
  
  # true if freezed, fixed familar members, all members passed any condition
  def secure?
    (frozen? || lock?) && self.class.closed? && strict?
  end

  def lock!(key=true)
    raise "can't modify frozen #{self.class}" if frozen?
    
    if key.equal? true
      names.each do |name|
        @_locks[name] = true
      end
    else
      _subscript(key){|name|@_locks[name] = true}
    end

    self
  end

  def locked?(key=true)
    if key.equal? true
      members.all?{|name|@_locks[name]}
    else
      _subscript(key) {|name|@_locks[name]} || false}
    end
  end
  
  private
  
  def unlock(key=true)
    raise "can't modify frozen #{self.class}" if frozen?
    
    if key.equal? true
      @_locks.clear
    else
      _subscript(key) {|name|@_locks.delete name}
    end

    self
  end

  def close
    [@_db, @_locks].each(&:freeze)
    self
  end

  def _get!(name)
    ret = @_db[name]
    attrs = self.class.__send__ :_attrs, name
    if attrs[:reader_validation] && attrs.has_key?(:is)
      if _valid? attrs[:is], ret
        ret
      else
        raise InvalidReadingError, "#{ret.inspect} is deficient for #{name} in #{self.class}"
      end
    else
      ret
    end
  end

  def _set!(name, value)
    attrs = self.class.__send__ :_attrs, name
    raise "can't modify frozen #{self.class}" if frozen?
    raise "can't modify locked member #{name}" if locked? name

    if adjuster = attrs[:via]
      begin
        value = instance_exec value, &adjuster
      rescue Exception
        raise ::Validation::UnmanagebleError
      end
    end

    if attrs[:writer_validation] and _valid?(attrs[:is), value)
      raise ::Validation::InvalidWritingError,
            "#{value.inspect} is deficient for #{name} in #{self.class}"
    end
  else
    @_db[name] = value
  end

  def _replace_values(*values)
    unless values.size <= size
      raise ArgumentError, "struct size differs (max: #{size})"
    end

    values.each_with_index do |value, index|
      self[index] = value
    end
      
    excess = members.last(size - values.size)
      
    excess.each do |name|
      if has_default? name
        self[name] = (
          if (value = default_for name).kind_of? SpecificContainer
            block = value.value
            args = [self, name][0, block.arity]
            block.call(*args)
          else
            value
          end
        )
      end
    end
  end

  # @param [Symbol] method
  def _compare(other, method)
    instance_of?(other.class) && \
    each_pair.all?{|k, v|v.__send__ method, other[k]}
  end

  
  def _subscript(key)
    case key
    when Symbol, String
      key = key.to_sym
      if member? key
        yield key
      else
        raise NameError
      end
    when Fixnum
      if name = members[key]
        yield name
      else
        raise IndexError
      end
    else
      raise ArgumentError
    end
  end

end
